package de.quinscape.exceedapp.config;

import com.google.common.collect.ImmutableMap;
import de.quinscape.exceed.model.domain.property.DomainProperty;
import de.quinscape.exceed.model.meta.PropertyType;
import de.quinscape.exceed.runtime.RuntimeContext;
import de.quinscape.exceed.runtime.action.Action;
import de.quinscape.exceed.runtime.action.ActionEnvironment;
import de.quinscape.exceed.runtime.action.CustomLogic;
import de.quinscape.exceed.runtime.action.ExceedContext;
import de.quinscape.exceed.runtime.component.DataGraph;
import de.quinscape.exceed.runtime.domain.DomainObject;
import de.quinscape.exceed.runtime.util.DomainUtil;
import de.quinscape.exceedapp.domain.tables.pojos.Address;
import de.quinscape.exceedapp.domain.tables.pojos.Customer;
import de.quinscape.exceedapp.domain.tables.pojos.Order;
import de.quinscape.exceedapp.domain.tables.pojos.Product;
import org.jooq.DSLContext;
import org.jooq.DatePart;
import org.jooq.Field;
import org.jooq.Table;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;

import java.math.BigDecimal;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

import static de.quinscape.exceedapp.domain.Tables.*;
import static org.jooq.impl.DSL.*;

@CustomLogic
public class ShopActions
{
    private final static Logger log = LoggerFactory.getLogger(ShopActions.class);

    private static final String ORDER_STATUS = "OrderStatus";

    private final DSLContext dslContext;

    /**
     * Static Column definition for {@link #queryOrderSums(int)}
     */
    private final static ImmutableMap<String, DomainProperty> ORDER_SUMS_COLUMNS = ImmutableMap.of(
        "label", DomainProperty.builder().withType(PropertyType.PLAIN_TEXT).build(),
        "value", DomainProperty.builder().withType(PropertyType.CURRENCY).build()
    );

    @Autowired
    public ShopActions(
        DSLContext dslContext
    )
    {
        this.dslContext = dslContext;
    }
    
    @Action(
        env = ActionEnvironment.SERVER
    )
    public String newCustomerNumber()
    {
        return findMaxPlusOne(CUSTOMER, CUSTOMER.NUMBER, "A%08d");
    }

    @Action(
        env = ActionEnvironment.SERVER
    )
    public String newOrderNumber()
    {
        return findMaxPlusOne(ORDER, ORDER.NUMBER, "B%08d");
    }


    @Action(
        env = ActionEnvironment.SERVER
    )
    public String newProductNumber()
    {
        return findMaxPlusOne(PRODUCT, PRODUCT.NUMBER, "P$08d");
    }

    private String findMaxPlusOne(
        Table<?> customer, Field<String> field,
        String format
    )
    {
        final Integer maxNumber = dslContext.select(
            max(
                cast(
                    substring(
                        field,
                        2
                    ),
                    Integer.class
                )
            )
        )
            .from(customer)
            .fetchOneInto(Integer.class);

        return String.format(format, maxNumber != null ? maxNumber + 1 : 1);
    }

    /**
     * Example of an action method with generated domain parameters. The classes are generated from JOOQ on the basis of
     * of the database generated by exceed. They're specialized POJO containers for a single domain type and offer
     * Java bean property access to the properties of that domain type
     *
     * @param runtimeContext
     * @param customer              customer object
     * @param billingAddress        billing address object, connected to customer
     * @param hasDeliveryAddress    <code>true</code> if this object is supposed to have a delivery address
     * @param deliveryAddress       delivery address which might be an address object connected to the customer, it might
     *                              just be an empty collection of null values co
     */
    @Action
    public void shopSaveCustomer(
        RuntimeContext runtimeContext,
        Customer customer,
        Address billingAddress,
        boolean hasDeliveryAddress,
        Address deliveryAddress
    )
    {
        if (hasDeliveryAddress)
        {
            final String deliveryAddressId;
            if (deliveryAddress.getId() == null)
            {
                deliveryAddressId = UUID.randomUUID().toString();
                deliveryAddress.setId(deliveryAddressId);
            }
            else
            {
                deliveryAddressId = deliveryAddress.getId();
            }

            customer.setDeliveryAddressId(deliveryAddressId);

            deliveryAddress.insertOrUpdate(runtimeContext);
            billingAddress.insertOrUpdate(runtimeContext);
            customer.insertOrUpdate(runtimeContext);
        }
        else
        {
            // we're ignoring the delivery address

            customer.setDeliveryAddressId(null);
            
            billingAddress.insertOrUpdate(runtimeContext);
            customer.insertOrUpdate(runtimeContext);
        }
    }

    @Action
    public void shopTakeOrder(
        RuntimeContext runtimeContext,
        Order current,
        @ExceedContext("orderItems") List<DomainObject> orderItems
    )
    {
        current.setProperty("sum", 0L);
        current.insert(runtimeContext);
        for (DomainObject orderItem : orderItems)
        {
            orderItem.insert(runtimeContext);
        }

        final Map<String, Product> products = DomainUtil.mapById(
            dslContext
                .select(PRODUCT.ID, PRODUCT.PRICE)
                .from(PRODUCT)
                .where(
                    PRODUCT.ID.in(
                        orderItems.stream()
                            .map(d -> d.getProperty("productId"))
                            .collect(Collectors.toList())
                    )
                )
                .fetchInto(Product.class)
        );

        long sum = 0;
        for (DomainObject orderItem : orderItems)
        {
            int quantity = (int) orderItem.getProperty("quantity");

            sum += quantity * products.get(orderItem.getProperty("productId")).getPrice();
        }

        current.setProperty("sum", sum);
        current.update(runtimeContext);

    }


    /**
     * Action based JOOQ query that provides the data for the status chart.
     *
     * @param months    Number of past months to look up
     *
     * @return  data graph to be injected into the bar chart component
     */
    @Action
    public DataGraph queryOrderSums(int months)
    {
        final List<Map> rows =
                dslContext.select(
                    trunc(ORDER.ACCEPTED, DatePart.MONTH).as("label"),
                    sum(PRODUCT.PRICE.multiply(ORDER_ITEM.QUANTITY))
                )

                .from(ORDER)
                    .join(ORDER_ITEM).on(
                        ORDER_ITEM.ORDER_ID.eq(ORDER.ID)
                    )
                    .join(PRODUCT).on(
                        ORDER_ITEM.PRODUCT_ID.eq(PRODUCT.ID)
                    )

                .where(
                    ORDER.STATUS.eq("PAID").and(
                        ORDER.ACCEPTED.greaterThan(Timestamp.valueOf(LocalDateTime.now().minus(months, ChronoUnit.MONTHS)))
                    )
                )

                .groupBy(field("label"))

                .orderBy(field("label")).fetch( r -> {

                    final Map<String, Object> map = new HashMap<>();

                    map.put("label", new SimpleDateFormat("MMM Y").format(r.getValue(0)));
                    map.put("value", ((BigDecimal)r.getValue(1)).longValue());
                    return map;
                });

        return new DataGraph(
            ORDER_SUMS_COLUMNS,
            rows,
            rows.size(),
            DataGraph.QUERY_QUALIFIER
        );
    }
}
